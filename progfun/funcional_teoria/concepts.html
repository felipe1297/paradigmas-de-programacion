<html>

<head>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/menu.css">
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <meta charset='utf-8'>
    <title>Programación funcional </title>
</head>

<body>
    <div class="todo">

        <ul class="menu">
            <li><a class="menu-item" href="index.html">Programación Funcional </a>
                <ul>
                    <li><a class="menu-item1" href="index.html#intro">Motivación</a></li>
                    <li><a class="menu-item1" href="index.html#history">Historia</a></li>
                    <li><a class="menu-item1" href="index.html#lambdacalc">C&aacute;lculo Lambda</a></li>
                    <li><a class="menu-item1" href="index.html#advantage_disadvantage">Ventajas y desventajas</a></li>
                    <li><a class="menu-item1" href="index.html#languages">Lenguajes</a></li>
                </ul>
            </li>
            <li><a href="concepts.html" class="menu-item">Conceptos</a></li>
            <li><a href="examples.html" class="menu-item">Ejemplos</a></li>
            <li><a href="applications.html" class="menu-item">Aplicaciones</a></li>

            <li><a class="menu-item" href="test.html">Test your knowledge!</a></li>
            <li><a class="menu-item" href="referencias.html">Referencias</a></li>
            <li><a class="menu-item" href="../../index.html">Volver a Index</a></li>
        </ul>


        <div class="head">
            <div class="titulo-principal text-center">
                <strong>
                    Programación Funcional
                </strong>
            </div>
        </div>

        <div class="container">

            <div class="row">
                <h1 class="text-center">Conceptos clave</h1>

                <p>A continuación veremos algunos conceptos referentes a la programación funcional.</p>
                <hr>
                <hr>


                <div class="row">
                    <h2>Pensamiento Funcional</h2>
                    <div class="col-md-12 text-justify">
                        <p>
                            El pensamiento funcional es la serie de habilidades e ideas que se aplican para resolver problemas funcionalmente.
                            Dos ideas importantes que debe aprender el programador funcional son:
                        </p>
                        <ol>
                            <li>Distinguir acciones, cálculos y datos</li>
                            <li>Usar abstracciones de primera clase</li>
                        </ol>
                        <p>Estas no son las únicas ideas de programación funcional, pero sí proporcionan una base sólida de ello.</p>
                    </div>
                    <hr>
                    <hr>

                    <h3>Distinguir acciones, cálculos y datos</h3>
                    <div class="col-md-6 text-justify">
                        <p>
                            Todo código se separa según las categorías de acciones, cálculos o datos. Estas corresponden a qué tan difícil es entender, testear y reusar el código.
                        </p>
                        <h4>Acciones</h4>
                        <p>
                            Son aquello que depende de cuándo y cuántas veces son llamados.
                            Son funciones con <a href="#side-effects">efectos secundarios</a>.<br>

                        <p> <i>Ejemplo:</i> Leer de una base de datos.</p>
                        </p>
                        <h4>Cálculos</h4>
                        <p>
                            Representan decisiones o planes. Estos no afectan el entorno al ser ejecutados.
                            Son <a href="#purefun">funciones puras</a>.<br>

                        <p> <i>Ejemplo:</i> Revisar si una dirección de correo es válida.</p>
                        </p>
                        <h4>Datos</h4>
                        <p>
                            Es información registrada sobre eventos, es inmutable y flexible y puede almacenarse, transferirse y usarse de múltiples maneras.<br>
                        <p> <i>Ejemplo:</i> Ordenes en un restaurante.</p>
                        </p>

                        <p>
                            Esta perspectiva se puede aplicar a cualquier situación, aunque al principio puede parecer abstracto, a medida que se práctica se mejora.<br>
                            Es importante tener en cuenta unos detalles finales:
                        <ul>
                            <li>Lo que parece una acción puede estar compuesto de otras acciones, cálculos o datos más pequeños.</li>
                            <li>Los cálculos pueden estar compuestos de cálculos y datos más pequeños. Al descomponerlo, este se vuelve un cálculo partido en dos, donde la salida del primero es la entrada para el segundo- </li>
                            <li>Los datos solo están compuestos de más datos. Debido a ello, si se tienen datos, se tiene garantía de cómo se comportarán.</li>
                        </ul>
                        </p>
                    </div>
                    <h3>Usar abstracciones de primera clase</h3>
                    <div class="col-md-6 text-justify">
                        <p>
                            Se hace uso de <a href="#firstclass-fun">funciones de primera clase</a>, estas son funciones que toman como argumento otras funciones.
                            Existen también valores de primera clase, son aquellos que se pueden pasar a una función, pueden ser retornados por una, se pueden guardar en arreglos,
                            asignar a un atributo de un objeto, se pueden asignar auna variable, entre otros.  En cambio, operadores aritméticos, ciclos, sentencias if, bloques try/catch,
                            son ejemplos de valores que no son de primera clase. <br>
                            La habilidad de identificar valores, funciones, entre otros, que no son de primera clase convertirlos a primera clase proporciona un gran poder para resolver problemas,
                            pues abre las puertas a patrones de programación funcional más sofisticados (Cabe resaltar que son patrones de PF, diferentes a los usualmente usados para POO).
                            Algunas ventajas son que permiten abstraer código, eliminar código duplicado, envolver código en funciones.
                        </p>
                        <img src="images/abstraction.jpg" width="50%" class="center-block" alt="">
                    </div>

                </div>

                <div id="purefun" class="row" >
                    <h2>Funciones Puras</h2>
                    <div class="col-md-8 text-justify">
                        <p>
                            Una función puede catalogarse como pura si cumple las siguientes dos condiciones:
                        </p>

                        <ul>
                            <li>
                                Dados los mismos parámetros de entrada, la función debe retornar siempre el mismo valor de salida, sin importar cuántas veces se llame.
                                Aquí se aplica el concepto de "Transparencial Referencial".
                            </li>
                            <li>
                                La función no debe tener "efectos secundarios", es decir, no debe tener ningún otro efecto en el entorno, aparte del cálculo del resultado objetivo.
                            </li>
                        </ul>
                    </div>

                    <div class="col-md-4 text-justify">
                        <img src="images/funcPuras.JPG" class="img-responsive img-thumbnail center-block" alt="">
                    </div>
                    
                    <div class="col-md-8 text-justify">
                        <p>
                            Las funciones puras son útiles porque se pueden ejecutar desordenadamente y en paralelo, cuando no hay dependencias de parámetros entre ellas.
                            Algunos ejemplos de estas los podemos ver en las funciones matemáticas y algoritmicas deterministas.
                            Son funciones impuras, por otro lado, los generadores de números aleatorios.
                        </p>
                    </div>
                </div>

                <div id="side-effects" class="row">
                    <h2>Efectos secundarios</h2>
                    <div class="col-md-8 text-justify">
                        <p>
                            Están referidos a los estados en los que puede estar el código mientras se ejecuta, una de
                            las
                            características ya mencionadas de la programación funcional es que es de tipo declarativo,
                            por
                            lo que no existe la variación de estados, estos efectos secundarios pueden referirse a:
                        </p>
                        <ul>
                            <li>
                                Cambiar el valor de cálculos realizados previamente.
                            </li>
                            <li>
                                Entrada - salida de datos estándar o por archivo.
                            </li>
                            <li>
                                Modificar uno de los argumentos de la función.
                            </li>
                        </ul>


                    </div>
                    <div class="col-md-4 text-justify">
                        <img src="images/side.png" class="img-responsive img-thumbnail center-block" alt="">

                    </div>
                    <h3>Ejemplos</h3>
                    <div class="row">
                        <div class="col-md-4 text-justify">
                            <h4>Loops</h4>
                            <p>
                                Los loops generan "side effects" debido a que se está cambiando el valor de una variable
                                para iterar y comparar, generando cambios de valor y por lo tanto cambiando la salida de
                                una
                                función o rutina.
                            </p>
                            <script src="https://gist.github.com/anonymous/ec5b8dcace25761bc383fcbacaec30ad.js">
                            </script>
                        </div>
                        <div class="col-md-4 text-justify">
                            <h4>Variable aleatorias</h4>
                            <p>Las variables generadas aleatoriamente generan side effects, ya que las funciones
                                evaluadas
                                con un número aleatorio no retornaran el mismo resultado ejecutadas dos veces.</p>
                            <script src="https://gist.github.com/anonymous/983ed3822c855389415b879a188673df.js">
                            </script>
                        </div>
                        <div class="col-md-4 text-justify">
                            <h4>Entrada de datos por consola en ejecución</h4>
                            <p>Los argumentos de entrada de un programa en programación funcional se asignan sólo al
                                principio de este (argumentos), en ejecución está prohibida la asignación de variables,
                                ya
                                que no garantizan que el código ejecutado dos veces sea exactamente igual.</p>
                            <script src="https://gist.github.com/anonymous/2e67f4c0389680965ce12a2ff94ede6b.js">
                            </script>
                        </div>
                    </div>
                </div>


                <hr>
                <hr>

                

                <div class="row">
                <h2>Recursión</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        En los lenguajes funcionales no existen los ciclos, esto con el objetivo de preservar la <a href="#inmutabilidad"> inmutabilidad</a>,
                        por ende, la técnica que se usa es reemplazarlos con funciones recursivas. A continuación un ejemplo de la misma función implementada con un
                        ciclo for y con recursión
                    </p>

                </div>
                <div class="col-md-6">
                    <h4>Haskell</h4>
                    <p>
                        En este ejemplo demostrativo de recursión se calcula el interés compuesto recursivamente.
                    </p>
                    <iframe src="https://paiza.io/projects/e/d-OVYU-bMeYRr4QRTr4eUQ?theme=tomorrow_night_eighties" width="100%" height="500" scrolling="no" seamless="seamless"></iframe>
                    <h4>Java</h4>
                    <script src="https://gist.github.com/anonymous/71553ee47bd9e61789fed5cad402ce8d.js"></script>

                </div>
                <h3>Recursión de Cola</h3>
                <div class="col-md-12 text-justify">
                    <p>
                        Dado que las recursiones se manejan guardando la información de los llamados en una pila, es posible que esto produzca
                        un error de 'StackOverFlow', para evitar esto se usa recursión de cola, esta es una función recursiva en la que la llamada a sí
                        misma es la última sentencia que ejecuta la función. Esta técnica evita que se desborde la pila dado que el compilador es capaz
                        de reescribirlo como un búcle.

                    </p>
                    <hr>
                    <hr>


                </div>
                <div class="col-md-6 text-justify">
                    <h4>Recursividad Normal</h4>
                    <script src="https://gist.github.com/SpaceCowboy03/e31c8cdaa9c9921a7c49034434588cee.js"></script>
                    <p>
                        A pesar de que el llamado recursivo <code>factorial(n-1)</code> aparece al final de la función, esta no es la última acción,
                        pues tras ejecutar esa sentencia aún es necesario realizar la multiplicación por <code>n</code>.
                    </p>

                </div>
                <div class="col-md-6 text-justify">
                    <h4>Tail Recursion</h4>
                    <script src="https://gist.github.com/SpaceCowboy03/afd3868cffef6d81f16e2f69f0464a41.js"></script>
                    <p>
                        En este caso, la llamada a <code>fact(k-1, k*result)</code>, sí es lo último en ejecutarse.
                    </p>

                </div>
                </div>

                <hr>
                <hr>

                <div class="row">
                    <h2>Modularidad</h2>
                    <div class="col-md-6">
                        <p>Modularidad para hallar la desviación estándar de una lista.</p>
                        <img src="images/Modularidad.png" alt="" class="img-responsive">
                        <br>
                        <p>Aplicación en Haskell:</p>
                        <br>
                        <script src="https://gist.github.com/anonymous/e968a52c2624d3e325c51f11ae3737df.js"></script>

                    </div>
                    <div class="col-md-6 text-justify">
                        <p>
                            Un problema complejo se puede descomponer en problemas más simples. Por ejemplo en
                            programación
                            funcional una serie de funciones realizadas secuencialmente podrían resolver la mayoría de
                            problemas de programación.
                        </p>

                    </div>
                </div>


            </div>

            <hr>
            <hr>

            <div class="row">
                <h2>Transparencia referencial</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Se dice que una expresión es referencialmente transparente sí se puede reemplazar con su valor
                        correspondiente sin cambiar el comportamiento del programa. Como resultado, la evaluación de una
                        función referencialmente da el mismo valor para los mismos argumentos. Estas funciones se llaman
                        funciones puras. Una expresión que no es referencialmente transparente se llama referencialmente
                        opaca.
                    </p>
                    <p>
                        En las matemáticas todas las aplicaciones de una función son referencialmente transparentes por
                        definición. Esto no pasa siempre en la programación, donde los términos procedimiento y método
                        se
                        utilizan para evitar connotaciones engañosas.
                    </p>
                    <p>
                        La importancia de la transparencia referencial es que permite al programador y al compilador
                        razonar
                        sobre el comportamiento del programa como un sistema de reescritura. Esto puede ayudar a probar
                        la
                        corrección, simplificar un algoritmo, ayudar a modificar el código sin romperlo, o optimizar el
                        código
                        mediante memoization, eliminación de subexpresión común, evaluación perezosa o paralelización.
                    </p>
                    <p>
                        Como la transparencia referencial requiere los mismos resultados para cualquier conjunto dado de
                        entradas en cualquier punto en el tiempo, una expresión referencialmente transparente es por lo
                        tanto determinista.
                    </p>

                </div>
                <div class="col-md-6 text-justify">
                    <h4>Ejemplos</h4>

                    <ul>
                        <li>
                            <p>Se tiene la siguiente función:</p>
                            <p>
                                int sumarUno(int x){ <br>
                                return x + 1;<br>
                                }<br>
                            </p>
                            <p>Es transparente, porque para cualquier valor de x no tendrá side effects.</p>
                        </li>
                        <li>
                            <p>Pero con una función de tiempo como:</p>
                            <p>
                                today();
                            </p>
                            <p>No es transparente, porque para un día como hoy retornará 1 de Octubre de 2017, pero
                                mañana no (llamando la función de la misma manera).</p>
                        </li>
                    </ul>

                </div>
            </div>

            <hr>
            <hr>

            <div class="row">
                <h2>Evaluación perezosa</h2>
                <div class="col-md-6 text-justify">
                    <ul>
                        <li>
                            Algunos lenguajes funciones no evalúan expresiones que no son usadas. Esto puede reducir el
                            tiempo de ejecución de algunas funciones en tiempo exponencial.
                        </li>
                        <li>
                            Permite declarar infinitos valores, ya que siempre y cuando sólo se use un número finito
                            solo estos se calcularán. Ver ejemplo en
                            <a href="http://ideone.com/8sd0yF">aquí</a>
                        </li>
                        <li>
                            Mediante la reducción por grafos, no se re-calculan expresiones o funciones ya evaluadas.
                            Esto reduce el costo computacional.
                        </li>
                    </ul>

                </div>
                <div class="col-md-6">
                    <img src="images/lazy.png" alt="" class="img-responsive center-block img-thumbnail">

                </div>
            </div>

            <div class="row">
                <h2>Inmutabilidad</h2>
                <div id="inmutabilidad" class="col-md-6 text-justify">
                    <p>
                        En general, tener estados mutables vuelve el código más complejo y es causa de errores, ya que dificulta hacer seguimiento a los valores cambiantes,
                        es por eso que en PF se busca tener objetos inmutables. Un objeto inmutable es aquel que no puede ser modificado una vez haya sido creado.
                        Podemos ver a los objeto inmutables como constantes, una vez nosotros asignamos un valor este no
                        podrá ser modificado. <br>
                        Teniendo en cuenta que un programa en programación funcional es inmutable, en ejecución está
                        prohibida la asignación de variables, ya que no garantizan que el código ejecutado dos veces sea
                        exactamente igual.


                    </p>

                </div>
                <div class="col-md-6">
                    <img src="images/Inmutabilidad.PNG" alt="" class="img-responsive center-block img-thumbnail">

                </div>
            </div>

            <div class="row">
                <h2>Tipos Algebraicos</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        En los lenguajes funcionales tipados como ML y Haskell ademas de los tipos tradicionales, 
                        támbien tenemos la posibilidad de declarar tipos adicionales segun lo necesitemos, los
                        cuales son declarados mediantes constructores y con los cuales tenemos la opcion de 
                        declarar listas recursivas, direcciones entre otros ejemplos.
                    </p>

                </div>
                <div class="col-md-6">
                    <img src="images/tiposAlgebraicos.png" class="img-responsive img-thumbnail center-block" alt="">
                    <img src="images/tiposAlgeRecursion.png" class="img-responsive img-thumbnail center-block" alt="">
                </div>
            </div>

            <div class="row">
                <h2>Emparejamiento de Patrones</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        El emparejamiento de patrones (en inglés Pattern Matching), se refiere a la posibilidad que
                        brindan algunos lenguajes funcionales de definir funciones a trozos o por casos, lo que nos
                        permite tener mayor capacidad expresiva al lenguaje, lo que quiere decir es que nos permite 
                        escribir el código más claro, sencillo y conciso.
                    </p>

                </div>
                <div class="col-md-6">
                    <h4>Aqui definimos una funcion que puede ser vacia o puede ser cons</h4>
                    <img src="images/emparejamientoPatrones.png" class="img-responsive img-thumbnail center-block" alt="">
                </div>
            </div>

            <div class="row">
                <h2>Composición de funciones</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        La composición de funciones es la imagen resultado de la aplicación sucesiva de dos o más 
                        funciones sobre un mismo elemento x.
                    </p>
                    <p>
                        En esencia funciona igual a la composición de funciones en matemáticas, así:
                    </p>
                    <p>
                        La composición de funciones se realiza aplicando dichas funciones en orden de derecha a izquierda, 
                        de manera que en (g o f)(x) primero actua la función f y luego la g sobre f(x).
                       
                    </p>

                </div>
                <div class="col-md-6">
                    <h4>Ejemplos de composición en lenguajes funcionales</h4>
                    <h4>Haskell</h4>
                    <p> Siguiendo con el ejemplo de g(x) y f(x), y usando la sintaxis de Haskell, la composición 
                        de funciones se excribiría de la siguiente manera: (g.f)(x).
                    </p>
                    <p>
                        En el siguiente snippet de Haskell se hace una composición de las funciones  sumarUno y multDiez.
                        Siguinedo el orden de ejecución de derecha a izquierda, primero se ejecutará multDiez usando como parámetro de 12, 
                        acto seguido el resultado de esta función (12*10 = 120) será tomado como parámetro en la función sumarUno, dando como resultado 120 + 1 = 121. 
                    
                    </p>
                    <iframe src="https://paiza.io/projects/e/ooZgGI_NaMqPM3upHj3jMg?theme=tomorrow_night_eighties" width="100%" height="500" scrolling="no" seamless="seamless"></iframe>

                    <br>
                     <h4>Scala</h4>
                    <p> En el caso de Scala la composición de funciones se hace usando la palabra clave compose, que con el ejemplo inicial quedaría (g compose f)(x).
                    </p>
                    <script src="https://pastebin.com/embed_js/hF4YuZg1"></script>

                </div>
            </div>

            <div class="row">
                <h2>Estado Compartido</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        El estado compartido es cualquier variable, objeto o espacio de memoria que exista en un ámbito compartido.
                        Un ámbito compartido incluye el alcance global o ámbitos de cierre.
                        
                        Un ejemplo de esto lo podemos observar en la programación orientada a objetos, donde los objetos se comparten entre ámbitos al agregar propiedades a otros objetos.
                        De la misa manera, el paradigma funcional toma esta propiedad para aplicarla en su ámbito de desarrollo.
                    </p>
                </div>

                <div class="col-md-6 text-justify">
                    <img src="images/estadoCompartido.JPG" class="img-responsive img-thumbnail center-block" alt="">
                </div>
            </div>

            <div class="row">
                <h2>Funciones de Orden Superior y de Primera Clase</h2>
                <div id="firstclass-fun" class="col-md-6 text-justify">
                    <h4>Funciones de Orden Superior</h4>
                    <p>
                        Son funciones que pueden tomar otras funciones como argumentos o devolverlas como resultado.
                        Estas funciones se pueden almacenar en variables
                        En cálculo , un ejemplo de una función de orden superior es el operador diferencial d / dx , que
                        devuelve la derivada de una función f, recibe una función de parámetro y devuelve otra función,
                        por ejemplo al derivar x^2, devuelve otra función que es 2x
                    </p>
                    <br>
                    <h4>Funciones de Primera Clase</h4>
                    <p>
                        También son funciones que pueden tomar o devolver otras funciones y se pueden almacenar como
                        variables.
                    </p>
                    <br>
                    <h4>¿Cuál es la diferencia?</h4>
                    <p>
                        Ambas se pueden tratar como cualquier otro valor del lenguaje, pero a las de primera clase no se
                        les debe hacer ningún tratamiento especial.
                    </p>
                </div>
                <div class="col-md-6 text-justify">
                    <h4>Ejemplo de una función de orden superior que no es de primera clase</h4>
                    <h4>Haskell</h4>
                    <p> 
                        En este ejemplo demostrativo de haskell la función applyTwice toma una función de números enteros como primer argumento y la aplica dos veces a su segundo argumento.

                        Los paréntesis aclaran que el primer conjunto Int debe leerse en conjunto para significar una función Int en lugar de dos valores Int independientes.
                        
                        En el siguiente snippet se crean algunas funciones de muestra: "double" y "next" para pasar a nuestra función de orden superior "applyTwice".
                    </p>
                    <iframe src="https://paiza.io/projects/e/MtzvMDPhBMB-2cbcQrFq7w?theme=tomorrow_night_eighties" width="100%" height="500" scrolling="no" seamless="seamless"></iframe>
                    <h4>Ruby</h4>
                     <p>En Ruby no se pueden pasar métodos como parámetros de otros métodos, pero si objetos,
                        por ello cuando se quiera hacer algo similar, se tiene que convertir el método que se quiere
                        pasar a un objeto.
                        Esto se puede realizar gracias al método lambda. Este es un claro ejemplo de una función de
                        orden superior pero
                        no de primera clase, ya que para poder pasar el método "hola" como parámetro del método
                        "metod1", fue necesario
                        hacerle algún tipo de parseo o transformación
                    </p><iframe src="https://paiza.io/projects/e/jXgCoX7uwt2GuFu7tH095w?theme=tomorrow_night_eighties" width="100%" height="500" scrolling="no" seamless="seamless"></iframe>
                    <br>
                   <h4>JavaScript</h4>
                   <p>En contraste con Ruby, Javascript permite que una función sin tratar pueda ser pasada como parámetro de otra función. Como ocurre en el siguiente ejemplo donde una función notada de manera original (no como una función anónima  o lambda) puede ser pasada como paramétro de cualquier otra función, en este caso como parámetro de la función map() de un arreglo.</p>
                   <iframe src="https://paiza.io/projects/e/TlXk_VLZF9PyLWfmJXPSvQ?theme=tomorrow_night_eighties" width="100%" height="550" scrolling="no" seamless="seamless"></iframe>
                    <br>
                    <h4>Ejemplo de una función de orden superior y de primera clase</h4>
                    <p>Haskell</p>
                    <script src="https://pastebin.com/embed_js/Snpf7bqV"></script>
                    <br>
                    <p>En este caso no fue necesario ningún tipo de parseo o similar para poder pasar un función como
                        parámetro de otra función (pasarle f a g), por ello es de orden superior y de primera clase.
                    </p>
                </div>
            </div>
            <div class="row">
                <h2>Clausura (Closure)</h2>
                <div class="col-md-6 text-justify">
                    <p>Una clausura o cerradura es cuando una función tiene la capacidad de recordar la información que
                        estaba en su contexto cuando fue declarada. En algunos casos, como en el de JavaScript, su
                        implementación se contradice con su naturaleza orientada a objetos, pues las referencias
                        encapsuladas en el contexto de la función pueden ser alteradas.</p>
                </div>
                <div class="col-md-6 text-justify">
                    <script src="https://gist.github.com/Heldeg/9de8c55aac5a65b2a1583b67c2280fb9.js"></script>
                </div>
            </div>
            <div class="row">
                <h2>Currificación</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Como parte del estilo tácito o “Point-Free”, se suele necesitar acciones adicionales para
                        permitir una mejor coherencia del código. Uno de ellos es la currificación, que consiste en
                        convertir una función de múltiples parámetros en una con un único parámetro, la cual retorna
                        otra función que espera los parámetros restantes de su definición. También existe el
                        proceso inverso
                        de descurrificación.
                    </p>
                    <h4>Ventajas de la Currificación</h4>
                    <p>
                        <ul>
                            <li>Podemos crear funciones nuevas simplemente pasando nuestras funciones de base con algunos parámetros.</li>
                            <li>Podemos transformar cualquier función que trabaje con un solo elemento en una que trabaje con una lista envolviéndola en un map.</li>
                            <li>Se pueden escribir pequeñas piezas de código que sean más fácil de reutilizar.</li>
                            <li>Es fácil de razonar sobre ellas.</li>
                            <li>Escribir funciones currificadas nos permitirá componer funciones.</li>
                        </ul>
                    </p>
                    
                </div>
                <div class="col-md-6 text-justify">
                    <script src="https://gist.github.com/Heldeg/eadadedfee1d98950cdefb95bfc76beb.js"></script>
                    <h4>JavaScript</h4>
                    <p>
                        Se ejemplificará este concepto clave de currificación haciendo uso de Javascript.
                    </p>
                    <p>
                        Javascript permite definir las funciones de manera estandar o como funciones anónimas. De la misma manera una función currificada puede estar definida como función estandar o como función anónima.
                    </p>
                    <p>
                        Al momento de ejecutar una función currifcada se puede hacer de 2 maneras: 
                        <ul>
                            <li>
                                Ejecutando la función que contiene a las demás n-1 funciones con n listas de argumentos (una lista por cada función) con la siguiente sintáxis: customFunction(argF1)(argF2)...(argFn)
                            </li>
                            <li>
                                Pasar un argumento y recibir la siguiente función en el stack de currificación. 
                            </li>
                        </ul>
                    </p>
                    <iframe src="https://paiza.io/projects/e/0K85peR95sLy4-vHDNk_Ug?theme=tomorrow_night_eighties" width="100%" height="500" scrolling="no" seamless="seamless"></iframe>
                </div>
            </div>
            <div class="row">
                <h2>Higher-Kinded Types (HKT)</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Los Higher-Kinded Types (HKT) son una caracter&iacute;stica avanzada en la programaci&oacute;n funcional que permite definir tipos que aceptan otros tipos como par&aacute;metros. Esto permite una mayor abstracci&oacute;n y reutilizaci&oacute;n de c&oacute;digo en el contexto de la programaci&oacute;n funcional.
                    </p>
                    <h3>Definici&oacute;n de HKT</h3>
                    <p>
                        Un Higher-Kinded Type se define como un tipo que toma otro tipo como par&aacute;metro. Aqu&iacute; hay un ejemplo sencillo de c&oacute;mo se puede definir un HKT:
                    </p>
                    <pre><code>
trait Container[F[_]] {
    def put[A](value: A): F[A]
    def get[A](container: F[A]): A
}
                    </code></pre>
                </div>
                <div class="col-md-6 text-justify">
                    <h3>Ejemplo de Uso</h3>
                    <p>
                        Un ejemplo com&uacute;n de HKT es el uso de listas como un contenedor gen&eacute;rico. Aqu&iacute; hay un ejemplo de c&oacute;mo usar listas con una clase que implementa el trait <code>Container</code>:
                    </p>
                    <pre><code>
object ListContainer extends Container[List] {
    def put[A](value: A): List[A] = List(value)
    def get[A](container: List[A]): A = container.head
}

val list = ListContainer.put(42)
val value = ListContainer.get(list)  // 42
                    </code></pre>
                    <h3>Ventajas de HKT</h3>
                    <p>
                        Los HKT permiten escribir c&oacute;digo m&aacute;s gen&eacute;rico y flexible, facilitando la abstracci&oacute;n sobre diferentes tipos de contenedores y estructuras de datos. Tambi&eacute;n son fundamentales para la definici&oacute;n de estructuras de datos y patrones de dise&ntilde;o m&aacute;s avanzados en muchos lenguajes funcionales.
                    </p>
                    <p>
                        <b>Ejemplo en Scala:</b>
                        <br>
                        En Scala, los HKT se utilizan ampliamente para definir estructuras de datos gen&eacute;ricas y patrones de dise&ntilde;o funcionales.
                    </p>
                </div>
            </div>
            <div class="row">
                <h2>Monads</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Una Monad es una abstracci&oacute;n que permite estructurar programas de forma modular. Las Monads permiten encadenar operaciones en contextos computacionales 
                        como listas, opciones o futuros. Una Monad debe implementar dos operaciones: <code>flatMap</code> y <code>unit</code> (a menudo llamado <code>pure</code>).
                    </p>
                    <h3>Definici&oacute;n de Monad</h3>
                    <p>
                        Una Monad se define como una clase con los m&eacute;todos <code>flatMap</code> y <code>unit</code>. Aqu&iacute; hay un ejemplo de una Monad sencilla:
                    </p>
                    <pre><code>
trait Monad[M[_]] {
    def flatMap[A, B](value: M[A])(func: A => M[B]): M[B]
    def unit[A](value: A): M[A]
}
                    </code></pre>
                </div>
                <div class="col-md-6 text-justify">
                    <h3>Concatenación de Métodos</h3>
                    <p>
                        Una de las características más poderosas de las Monads es su capacidad para encadenar operaciones, lo que se conoce como concatenación de métodos. Esto permite construir secuencias de operaciones que se aplican una tras otra de manera limpia y manejable.
                    </p>
                    <h4>Ejemplo de Uso con Option Monad</h4>
                    <p>
                        Considere el caso de la Monad <code>Option</code>, que representa un valor que puede estar presente o no. Aquí hay un ejemplo de cómo usar <code>Option</code> para encadenar operaciones:
                    </p>
                    <pre><code>
val maybeInt: Option[Int] = Some(5)
val result: Option[String] = maybeInt
    .flatMap(x => Some(x * 2))         // Multiplica el valor por 2
    .flatMap(x => Some(x + 3))         // Suma 3 al resultado
    .flatMap(x => Some(x.toString))    // Convierte el resultado a String

// result es Some("13")
                    </code></pre>
                    <h4>Leyes de Monad</h4>
                    <p>
                        Las Monads deben cumplir con tres leyes: identidad izquierda, identidad derecha y asociatividad. Estas leyes aseguran que las Monads se comporten de manera predecible y consistente.
                    </p>
                </div>
            </div>
            <div class="row">
                <h2>Functor</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Un Functor es una abstracci&oacute;n que permite aplicar una funci&oacute;n a un valor dentro de un contexto. Los Functors se implementan con el m&eacute;todo <code>map</code>. 
                        Un Functor debe cumplir con dos leyes: identidad y composici&oacute;n.
                    </p>
                    <h3>Definici&oacute;n de Functor</h3>
                    <p>
                        Un Functor se define como una clase con el m&eacute;todo <code>map</code>. Aqu&iacute; hay un ejemplo de un Functor sencillo:
                    </p>
                    <pre><code>
trait Functor[F[_]] {
    def map[A, B](value: F[A])(func: A => B): F[B]
}
                    </code></pre>
                </div>
                <div class="col-md-6 text-justify">
                    <h3>Ejemplo de Uso</h3>
                    <p>
                        Un ejemplo com&uacute;n de un Functor es la clase <code>List</code>. Aqu&iacute; hay un ejemplo de c&oacute;mo usar <code>List</code> como un Functor:
                    </p>
                    <pre><code>
val numbers = List(1, 2, 3, 4)
val doubled = numbers.map(_ * 2)
// doubled es List(2, 4, 6, 8)
                    </code></pre>
                    <h3>Leyes de Functor</h3>
                    <p>
                        Los Functors deben cumplir con dos leyes: la ley de identidad (map con la funci&oacute;n identidad no cambia el Functor) y la ley de composici&oacute;n (map con la composici&oacute;n de dos funciones es igual a map con la primera funci&oacute;n y luego map con la segunda).
                    </p>
                    <p>
                        <b>Ejemplo en Scala:</b>
                        <br>
                        En Scala, los Functors son ampliamente utilizados en las colecciones y otros contextos que admiten transformaciones.
                    </p>
                </div>
            </div>
            <div class="row">
                <h2>ADTs (Algebraic Data Types)</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Los Tipos de Datos Algebraicos (ADTs) son una forma de definir tipos de datos compuestos. Los dos ADTs m&aacute;s comunes son los productos (casos de clase) y las sumas (jerarqu&iacute;as selladas).
                    </p>
                    <h3>Definici&oacute;n de ADTs</h3>
                    <p>
                        Un tipo de producto se define utilizando casos de clase, y un tipo de suma se define utilizando una jerarqu&iacute;a sellada. Aqu&iacute; hay un ejemplo de cada uno:
                    </p>
                    <h4>Tipo de Producto</h4>
                    <pre><code>
case class Person(name: String, age: Int)
                    </code></pre>
                </div>
                <div class="col-md-6 text-justify">
                    <h4>Tipo de Suma</h4>
                    <pre><code>
sealed trait Shape
case class Circle(radius: Double) extends Shape
case class Rectangle(width: Double, height: Double) extends Shape
                    </code></pre>
                    <h3>Ejemplo de Uso</h3>
                    <p>
                        Aqu&iacute; hay un ejemplo de c&oacute;mo usar ADTs:
                    </p>
                    <pre><code>
val shape: Shape = Circle(5.0)
shape match {
    case Circle(r) => println(s"Circle with radius $r")
    case Rectangle(w, h) => println(s"Rectangle with width $w and height $h")
}
                    </code></pre>
                    <p>
                        <b>Ejemplo en Scala:</b>
                        <br>
                        En Scala, los ADTs son fundamentales para definir estructuras de datos complejas de manera segura y expresiva.
                    </p>
                </div>
            </div>
            <div class="row">
                <h2>Typeclass</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Una Typeclass es un patr&oacute;n de dise&ntilde;o que permite la adici&oacute;n de nuevas funcionalidades a los tipos existentes sin modificar su c&oacute;digo. Las Typeclasses se implementan utilizando traits y la implementaci&oacute;n impl&iacute;cita de m&eacute;todos.
                    </p>
                    <h3>Definici&oacute;n de Typeclass</h3>
                    <p>
                        Una Typeclass se define como un trait con m&eacute;todos que describen las operaciones soportadas. Aqu&iacute; hay un ejemplo de una Typeclass:
                    </p>
                    <pre><code>
trait Show[A] {
    def show(value: A): String
}
                    </code></pre>
                </div>
                <div class="col-md-6 text-justify">
                    <h3>Implementaci&oacute;n de Typeclass</h3>
                    <p>
                        Para implementar una Typeclass para un tipo espec&iacute;fico, se proporciona una implementaci&oacute;n impl&iacute;cita del trait. Aqu&iacute; hay un ejemplo:
                    </p>
                    <pre><code>
implicit val intShow: Show[Int] = new Show[Int] {
    def show(value: Int): String = value.toString
}
                    </code></pre>
                    <h3>Uso de Typeclass</h3>
                    <p>
                        Para usar una Typeclass, se usa la resoluci&oacute;n impl&iacute;cita. Aqu&iacute; hay un ejemplo de c&oacute;mo usar una Typeclass:
                    </p>
                    <pre><code>
def printValue[A](value: A)(implicit s: Show[A]): Unit = {
    println(s.show(value))
}
printValue(123)  // "123"
                    </code></pre>
                    <p>
                        <b>Ejemplo en Scala:</b>
                        <br>
                        En Scala, las Typeclasses son un patr&oacute;n poderoso para la extensibilidad y la abstracci&oacute;n en la programaci&oacute;n funcional.
                    </p>
                </div>
            </div>

            <div class="row">
                <h2>Aplicación Parcial</h2>
                <div class="col-md-6 text-justify">
                    <p>
                        Consiste en fijar algunos de los argumentos de la función. El proceso es simple: se define una
                        función currificada y se aplica hasta un punto específico, obteniendo una función para la que
                        aún hay
                        argumentos esperados.
                    </p>
                </div>
                <div class="col-md-6 text-justify">
                    <script src="https://gist.github.com/Heldeg/4108a40081039098c603a73e0d3ccf54.js"></script>
                </div>
            </div>

            <hr>
            <hr>



        </div>

        <div class="footer">
            <div style="text-align: center;">
                <a href="index.html">PF</a> |
                <a href="test.html">Test your knowledge!</a>
            </div>
            <br>
            <div class="footer-text">
                <div style="text-align: center;">
                    Creado y modificado por: Daniel Cifuentes, Alejandra Zaldua (Estudiantes Ingeniería de Sistemas y
                    computación)
                    <br>
                    <br>
                    <p>Copyright &copy; Paradigmas de Programación - UNAL 2017</p>
                </div>
            </div>
        </div>

        <script src="js/jquery.js">
        </script>
        <script src="js/bootstrap.min.js">
        </script>

    </div>
</body>

</html>